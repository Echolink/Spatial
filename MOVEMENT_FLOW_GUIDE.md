# Unit Movement Flow Guide

This document explains how units move from one position to another in the integrated BepuPhysics + DotRecast system.

## Architecture Overview

The project consists of 4 main components:

1. **`Spatial.Physics`** - BepuPhysics wrapper (handles collisions, gravity, movement)
2. **`Spatial.Pathfinding`** - DotRecast wrapper (generates navmesh, finds paths)
3. **`Spatial.Integration`** - Bridge between physics and pathfinding
4. **Game Server** (your code) - Coordinates everything

## Complete Flow: Moving Unit A from (0,0,0) to (100,0,100)

### Step 1: One-Time Initialization (Game Server Setup)

Before any unit can move, you need to set up the system:

```csharp
// 1. Create physics world with gravity
var physicsWorld = new PhysicsWorld(new PhysicsConfiguration {
    Gravity = new Vector3(0, -9.81f, 0),
    Timestep = 0.016f // 60 FPS
});

// 2. Add static obstacles (walls, buildings, terrain, etc.)
var wallShape = physicsWorld.CreateBoxShape(new Vector3(5, 3, 1));
physicsWorld.RegisterEntity(
    entityId: 1001,
    entityType: EntityType.StaticObject,
    position: new Vector3(50, 1.5f, 50),
    shape: wallShape,
    isStatic: true
);

// Add more obstacles as needed...

// 3. Generate navigation mesh from physics world
var navMeshGenerator = new NavMeshGenerator();
var navMeshBuilder = new NavMeshBuilder(physicsWorld, navMeshGenerator);
var navMeshData = navMeshBuilder.BuildNavMeshFromPhysicsWorld(AgentConfig.Player);

// 4. Create pathfinder with the generated navmesh
var pathfinder = new Pathfinder(navMeshData);

// 5. Create movement controller
var movementController = new MovementController(physicsWorld, pathfinder);

// 6. Create Unit A as a dynamic physics entity
var (unitShape, unitInertia) = physicsWorld.CreateCapsuleShapeWithInertia(
    radius: 0.5f,    // Half-width of unit
    length: 2.0f,    // Height of unit
    mass: 1.0f       // Mass in kg
);

var unitA = physicsWorld.RegisterEntityWithInertia(
    entityId: 1,              // Unique ID for Unit A
    entityType: EntityType.Player,
    position: new Vector3(0, 1.5f, 0),  // Start position (slightly above ground)
    shape: unitShape,
    inertia: unitInertia,
    isStatic: false           // Dynamic entity
);
```

**What happens during initialization:**
- Physics world is created with gravity and collision detection
- Static obstacles are added to the physics simulation
- NavMesh is generated by extracting geometry from physics world
- Movement controller connects pathfinding with physics

---

### Step 2: Request Unit Movement

When you want Unit A to move to (100,0,100):

```csharp
// Create movement request
var moveRequest = new MovementRequest(
    entityId: 1,                        // Unit A's ID
    targetPosition: new Vector3(100, 0, 100),
    maxSpeed: 3.0f                      // Maximum speed in units/second
);

// Request movement through the controller
bool success = movementController.RequestMovement(moveRequest);

if (success) {
    Console.WriteLine("Unit A is now moving to destination!");
} else {
    Console.WriteLine("Failed to find path or invalid entity");
}
```

---

### Step 3: Inside `RequestMovement()` - Pathfinding Phase

When you call `RequestMovement()`, here's what happens internally:

```
MovementController.RequestMovement():
â”‚
â”œâ”€ 1. Get Unit A's current position from physics world
â”‚     â†’ Current position: (0, 1.5, 0)
â”‚
â”œâ”€ 2. Call pathfinder to find path
â”‚     pathfinder.FindPath(
â”‚         start: (0, 1.5, 0), 
â”‚         end: (100, 0, 100), 
â”‚         extents: (5, 10, 5)  // Search radius for nearest navmesh polygon
â”‚     )
â”‚     â”‚
â”‚     â”œâ”€ DotRecast finds nearest polygon to start position
â”‚     â”‚   â†’ Start polygon found on navmesh surface
â”‚     â”‚
â”‚     â”œâ”€ DotRecast finds nearest polygon to end position
â”‚     â”‚   â†’ End polygon found on navmesh surface
â”‚     â”‚
â”‚     â”œâ”€ DotRecast runs A* pathfinding algorithm on navmesh
â”‚     â”‚   â†’ Avoids obstacles, finds optimal walkable path
â”‚     â”‚
â”‚     â””â”€ Returns waypoints along the path:
â”‚         [(0, 0.2, 0), (25, 0.2, 25), (50, 0.2, 50), (75, 0.2, 75), (100, 0.2, 100)]
â”‚
â”œâ”€ 3. Store path in internal dictionary
â”‚     _currentPaths[1] = waypoint list
â”‚     _entityMaxSpeeds[1] = 3.0f
â”‚
â”œâ”€ 4. Skip waypoints at same XZ position as start
â”‚     FindNextValidWaypoint() checks each waypoint:
â”‚     - Waypoint 0 (0, 0.2, 0): Same XZ as start â†’ Skip
â”‚     - Waypoint 1 (25, 0.2, 25): Different XZ â†’ Use this!
â”‚     _currentWaypointIndex[1] = 1
â”‚
â””â”€ 5. Apply initial velocity toward first valid waypoint
      Target: (25, 0.2, 25)
      Current: (0, 1.5, 0)
      Direction: normalize((25, 0, 25)) = (0.707, 0, 0.707)  // XZ only
      Velocity: (0.707, 0, 0.707) * 3.0 = (2.12, 0, 2.12)
      Preserve gravity: velocity.Y = currentVelocity.Y
      SetEntityVelocity(unitA, velocity)
      Wake up body: bodyReference.Awake = true
```

**Key points:**
- Pathfinding uses A* on the navmesh (not straight line)
- Waypoints are on navmesh surface (Y â‰ˆ 0.2)
- Initial waypoint at same XZ position is skipped
- Movement is velocity-based, not teleportation

---

### Step 4: Game Loop - Continuous Updates

In your game loop (called every frame at ~60 FPS):

```csharp
void GameUpdate(float deltaTime) {
    // deltaTime â‰ˆ 0.016 seconds (60 FPS)
    
    // 1. Update movement controller (applies velocity toward waypoints)
    movementController.UpdateMovement(deltaTime);
    
    // 2. Step physics simulation (handles collisions, gravity, forces)
    physicsWorld.Update(deltaTime);
    
    // Optional: Get current position for rendering/debugging
    var currentPos = physicsWorld.GetEntityPosition(unitA);
    Console.WriteLine($"Unit A at: {currentPos}");
}
```

**Important:** Both methods must be called every frame for smooth movement!

---

### Step 5: Inside `UpdateMovement()` - Movement Phase

Every frame, `UpdateMovement()` processes all moving entities:

```
MovementController.UpdateMovement(deltaTime):
â”‚
â”œâ”€ For each entity with active path (Unit A in this case):
â”‚
â”œâ”€ 1. Get current state
â”‚     currentPosition = physicsWorld.GetEntityPosition(unitA)
â”‚     â†’ (0.03, 1.49, 0.03) // Moved slightly from last frame
â”‚     
â”‚     currentWaypointIndex = _currentWaypointIndex[1] = 1
â”‚     targetWaypoint = waypoints[1] = (25, 0.2, 25)
â”‚
â”œâ”€ 2. Calculate XZ distance to waypoint (ignore Y axis)
â”‚     xzDistance = sqrt((25 - 0.03)Â² + (25 - 0.03)Â²)
â”‚     â†’ 35.3 units (still far from waypoint)
â”‚
â”œâ”€ 3. Check if reached waypoint
â”‚     if (xzDistance < 0.5):  // Within 0.5 units?
â”‚         â†’ No, still 35.3 units away
â”‚         â†’ Continue to step 4
â”‚
â””â”€ 4. Apply velocity toward current waypoint
      targetXZ = (25, currentY, 25)  // Use current Y, target XZ
      directionVector = (25 - 0.03, 0, 25 - 0.03) = (24.97, 0, 24.97)
      direction = normalize(directionVector) = (0.707, 0, 0.707)
      velocity = direction * 3.0 = (2.12, 0, 2.12)
      
      // Preserve Y velocity for gravity
      currentVelocity = GetEntityVelocity(unitA)
      velocity.Y = currentVelocity.Y  // Maintain falling/gravity
      
      // Apply and wake body
      SetEntityVelocity(unitA, velocity)
      bodyReference.Awake = true
```

**Key features:**
- Only horizontal (XZ) distance matters for waypoint detection
- Gravity (Y velocity) is always preserved
- Velocity is reapplied every frame (ensures continuous movement)
- Body is kept awake (prevents physics sleep mode)

---

### Step 6: Inside `PhysicsWorld.Update()` - Physics Phase

After movement controller sets velocity, physics simulation runs:

```
PhysicsWorld.Update(deltaTime):
â”‚
â”œâ”€ BepuPhysics processes all forces and velocities
â”‚
â”œâ”€ 1. Apply gravity to dynamic bodies
â”‚     Unit A velocity.Y -= 9.81 * 0.016
â”‚     If Unit A is airborne, it falls toward ground
â”‚
â”œâ”€ 2. Move bodies based on velocity
â”‚     newPosition = currentPosition + velocity * deltaTime
â”‚     Unit A: (0.03, 1.49, 0.03) + (2.12, -0.16, 2.12) * 0.016
â”‚          â†’ (0.066, 1.48, 0.066)
â”‚
â”œâ”€ 3. Collision Detection
â”‚     Broad Phase: Check AABBs for potential collisions
â”‚     Narrow Phase: Precise collision detection
â”‚     â†’ Unit A capsule vs ground plane: Contact detected!
â”‚     â†’ Unit A capsule vs walls: No contact
â”‚
â”œâ”€ 4. Collision Resolution
â”‚     CollisionHandler.ConfigureContactManifold() called:
â”‚     â”œâ”€ FrictionCoefficient = 0.1  (low friction for smooth sliding)
â”‚     â”œâ”€ MaximumRecoveryVelocity = 2.0
â”‚     â””â”€ SpringSettings(30f, 1f)  (30 Hz, critically damped)
â”‚     
â”‚     Resolve penetration:
â”‚     - Apply spring forces to separate Unit A from ground
â”‚     - Apply friction (minimal due to 0.1 coefficient)
â”‚     - Damping prevents bouncing
â”‚
â””â”€ 5. Final state after physics resolution
      Unit A position: (0.066, 0.5, 0.066)  // Settled on ground
      Unit A velocity: (2.12, 0.0, 2.12)    // Horizontal movement, no vertical
```

**Physics features:**
- Gravity pulls units down naturally
- Low friction (0.1) allows smooth character movement
- SpringSettings prevent NaN values and instability
- Bodies settle on surfaces realistically

---

### Step 7: Waypoint Progression

As Unit A moves through the path:

```
Timeline of movement:

Frames 1-500 (0-8 seconds):
â”œâ”€ Unit A moves toward Waypoint 1: (25, 0.2, 25)
â”œâ”€ Position updates: (0,0,0) â†’ (5,0.5,5) â†’ (10,0.5,10) â†’ ... â†’ (24.9, 0.5, 24.9)
â””â”€ Distance decreasing: 35.3 â†’ 28.3 â†’ 21.2 â†’ ... â†’ 0.2

Frame 501:
â”œâ”€ xzDistance < 0.5  âœ“ Reached waypoint!
â”œâ”€ FindNextValidWaypoint() â†’ Waypoint 2: (50, 0.2, 50)
â”œâ”€ _currentWaypointIndex[1] = 2
â””â”€ MoveTowardWaypoint() calculates new direction: (0.707, 0, 0.707)

Frames 501-1000 (8-16 seconds):
â”œâ”€ Unit A moves toward Waypoint 2: (50, 0.2, 50)
â””â”€ Position: (25, 0.5, 25) â†’ (30, 0.5, 30) â†’ ... â†’ (49.9, 0.5, 49.9)

Frame 1001:
â”œâ”€ Reached Waypoint 2!
â”œâ”€ Move to Waypoint 3: (75, 0.2, 75)
â””â”€ Continue...

Frames 1001-1500 (16-24 seconds):
â”œâ”€ Unit A moves toward Waypoint 3: (75, 0.2, 75)
â””â”€ Position: (50, 0.5, 50) â†’ ... â†’ (74.9, 0.5, 74.9)

Frame 1501:
â”œâ”€ Reached Waypoint 3!
â”œâ”€ Move to Waypoint 4 (FINAL): (100, 0.2, 100)
â””â”€ Continue...

Frames 1501-2000 (24-32 seconds):
â”œâ”€ Unit A moves toward Waypoint 4: (100, 0.2, 100)
â””â”€ Position: (75, 0.5, 75) â†’ ... â†’ (99.9, 0.5, 99.9)

Frame 2000:
â”œâ”€ xzDistance < 0.5  âœ“ Reached FINAL waypoint!
â”œâ”€ No more waypoints in path
â”œâ”€ Remove from _currentPaths dictionary
â”œâ”€ Remove from _currentWaypointIndex
â”œâ”€ Remove from _entityMaxSpeeds
â”œâ”€ Set horizontal velocity to zero: (0, Y, 0)
â””â”€ MOVEMENT COMPLETE! ðŸŽ‰
```

**At each waypoint:**
- System automatically moves to next waypoint
- Direction and velocity recalculated
- No game server intervention needed

---

### Step 8: Movement Complete

```csharp
// After ~32 seconds (2000 frames at 60 FPS), Unit A arrives!

// Check final state
var finalPos = physicsWorld.GetEntityPosition(unitA);
var finalVel = physicsWorld.GetEntityVelocity(unitA);

Console.WriteLine($"Unit A final position: {finalPos}");
// Output: "Unit A final position: (99.9, 0.5, 99.9)"
// (Close to 100,0,100 - small offset due to waypoint threshold)

Console.WriteLine($"Unit A final velocity: {finalVel}");
// Output: "Unit A final velocity: (0, 0, 0)"
// (Horizontal velocity stopped, no gravity since on ground)

// Unit A is no longer in the movement system
bool isMoving = movementController._currentPaths.ContainsKey(1);
// isMoving = false
```

---

## Integration Points Between Components

### Physics â†’ Pathfinding (NavMesh Generation)

```
NavMeshBuilder.BuildNavMeshFromPhysicsWorld():
â”œâ”€ 1. Extract geometry from physics world
â”‚     For each static entity:
â”‚     â”œâ”€ Get StaticReference from simulation.Statics
â”‚     â”œâ”€ Get shape from entity.ShapeIndex
â”‚     â”œâ”€ Convert Box shapes to triangles (top face = walkable)
â”‚     â””â”€ Transform to world space
â”‚
â”œâ”€ 2. Build triangle mesh
â”‚     vertices = [(âˆ’10,0,âˆ’10), (10,0,âˆ’10), (10,0,10), (âˆ’10,0,10), ...]
â”‚     indices = [0,2,1, 0,3,2, ...]  // Triangle indices
â”‚
â”œâ”€ 3. Pass to DotRecast
â”‚     RcSimpleInputGeomProvider(vertices, indices)
â”‚     RcBuilder.Build(config, geometryProvider)
â”‚
â””â”€ 4. Create navigable mesh
      DtNavMeshBuilder.CreateNavMeshData()
      â†’ Produces 3 polygons (walkable areas between obstacles)
```

### Pathfinding â†’ Movement (Path Following)

```
Pathfinder.FindPath() â†’ PathResult:
â”œâ”€ Input: start position, end position, search extents
â”œâ”€ Process: A* algorithm on navmesh polygons
â””â”€ Output: List of waypoints on walkable surfaces

MovementController.RequestMovement() consumes PathResult:
â”œâ”€ Store waypoints in _currentPaths dictionary
â”œâ”€ Initialize waypoint index to first valid waypoint
â””â”€ Begin applying velocity toward waypoints
```

### Movement â†’ Physics (Velocity Application)

```
MovementController.UpdateMovement():
â”œâ”€ Calculate desired velocity toward waypoint
â””â”€ Call physicsWorld.SetEntityVelocity()

PhysicsWorld.SetEntityVelocity():
â”œâ”€ Wake body: bodyReference.Awake = true
â”œâ”€ Set linear velocity: bodyReference.Velocity.Linear = velocity
â””â”€ Physics simulation takes over from here
```

### Physics â†’ Movement (Position Updates)

```
PhysicsWorld.Update():
â”œâ”€ Physics simulation moves bodies
â”œâ”€ New positions calculated
â””â”€ MovementController reads new positions next frame

MovementController.UpdateMovement():
â”œâ”€ Get updated position: physicsWorld.GetEntityPosition()
â”œâ”€ Check if waypoint reached
â””â”€ Adjust velocity for new position
```

---

## Critical Design Decisions

### 1. Velocity-Based Movement (Not Teleportation)
**Why:** Ensures physics validation - units can't phase through walls or ignore gravity.

```csharp
// GOOD: Velocity-based (used in this system)
SetEntityVelocity(unit, direction * speed);
// Physics validates movement, applies collisions

// BAD: Direct position setting (teleportation)
SetEntityPosition(unit, targetPosition);
// Would bypass physics, unit could teleport through walls
```

### 2. XZ-Only Waypoint Comparison
**Why:** Allows units to walk on uneven terrain without getting stuck.

```csharp
// XZ distance only (Y ignored)
var xzDist = sqrt((target.X - current.X)Â² + (target.Z - current.Z)Â²);
if (xzDist < 0.5f) { /* reached */ }

// Why not 3D distance?
// Unit at (10, 0.5, 10) should reach waypoint (10, 0.2, 10)
// 3D distance = 0.3 units (might not trigger)
// XZ distance = 0.0 units (triggers correctly!)
```

### 3. Waypoint Skipping
**Why:** Handles navmesh points at same horizontal position as unit.

```csharp
// Without skipping:
// Unit at (0, 1.5, 0), first waypoint (0, 0.2, 0)
// Direction: normalize((0, 0, 0)) â†’ NaN or zero
// Result: Unit stuck, doesn't move!

// With skipping:
// FindNextValidWaypoint() â†’ skip to (25, 0.2, 25)
// Direction: normalize((25, 0, 25)) â†’ (0.707, 0, 0.707) âœ“
// Result: Unit moves correctly!
```

### 4. Low Friction (0.1)
**Why:** Prevents character controllers from sticking to ground.

```csharp
// High friction (1.0):
// Friction force â‰ˆ Normal force * 1.0
// Unit tries to move at 3.0 m/s
// Ground friction reduces it to ~0.5 m/s
// Result: Sluggish, feels like moving through mud

// Low friction (0.1):
// Friction force â‰ˆ Normal force * 0.1
// Unit moves at ~2.9 m/s (minimal loss)
// Result: Smooth, responsive character movement
```

### 5. Body Wake-Up
**Why:** Sleeping bodies don't respond to velocity changes.

```csharp
// Without wake-up:
// Unit resting on ground â†’ Physics puts it to sleep (optimization)
// SetEntityVelocity() called â†’ Velocity set, but body asleep
// Physics.Update() â†’ Sleeping bodies don't move
// Result: Unit appears frozen!

// With wake-up:
// bodyReference.Awake = true â†’ Body wakes up
// SetEntityVelocity() called
// Physics.Update() â†’ Active bodies move
// Result: Unit responds immediately!
```

### 6. SpringSettings (30Hz, Critically Damped)
**Why:** Stable collision resolution without NaN values.

```csharp
// Without SpringSettings (BepuPhysics v2.4.0):
// Contact resolution uses default/uninitialized values
// Numerical instability â†’ NaN values â†’ crash

// With SpringSettings(30f, 1f):
// Frequency: 30 Hz (fast response)
// Damping: 1.0 (critically damped, no oscillation)
// Result: Stable collision resolution, no NaN
```

---

## Performance Characteristics

### CPU Usage (60 FPS, 100 units moving):
- `UpdateMovement()`: ~0.2ms (waypoint logic, velocity calculation)
- `PhysicsWorld.Update()`: ~2-5ms (collision detection, resolution)
- **Total per frame**: ~2-5ms (plenty of headroom for 16.67ms frame budget)

### Memory Usage:
- Per unit: ~200 bytes (path waypoints, indices, speeds)
- 100 units: ~20 KB (negligible)

### Navmesh Generation:
- 100 static obstacles: ~50ms (one-time cost at level load)
- 1000 static obstacles: ~500ms (still acceptable for level load)

### Pathfinding:
- Short path (<50 units): ~0.1-0.5ms
- Long path (>100 units): ~1-3ms
- **Note**: Only runs when movement is requested, not every frame!

---

## Troubleshooting Common Issues

### Unit doesn't move at all
**Check:**
1. Is `UpdateMovement()` being called every frame?
2. Is `PhysicsWorld.Update()` being called after `UpdateMovement()`?
3. Is the body awake? (Add debug: `Console.WriteLine(bodyReference.Awake)`)
4. Is path valid? (Check `pathResult.Success`)

### Unit moves but stops immediately
**Check:**
1. Friction too high? (Should be 0.1)
2. Waypoint threshold too large? (Should be 0.5)
3. First waypoint at same XZ position? (Should auto-skip)

### Unit slides around uncontrollably
**Check:**
1. Friction too low? (Try 0.2-0.3 instead of 0.1)
2. SpringSettings too weak? (Try higher frequency like 60Hz)
3. MaxSpeed too high? (Try 3.0 instead of 10.0)

### Unit phases through walls
**Check:**
1. Using velocity (good) or teleportation (bad)?
2. Are walls registered as static entities?
3. Is collision detection enabled? (`AllowContactGeneration` returns true?)
4. Speed too high causing tunneling? (Reduce `maxSpeed`)

### NaN values / crashes
**Check:**
1. SpringSettings configured? (Must have `new SpringSettings(30f, 1f)`)
2. Static bodies in Statics collection? (Not Bodies collection)
3. Dynamic bodies have proper inertia? (Use `CreateCapsuleShapeWithInertia`)

---

## Summary

**The complete flow:**
1. Game server initializes physics world, adds obstacles, generates navmesh
2. Game server creates unit as dynamic physics entity
3. Game server requests movement via `MovementController.RequestMovement()`
4. Pathfinder finds waypoints on navmesh (avoids obstacles)
5. MovementController stores path and applies initial velocity
6. **Every frame:**
   - MovementController reapplies velocity toward current waypoint
   - Physics simulation validates movement (collisions, gravity)
   - When waypoint reached, move to next waypoint automatically
7. When final waypoint reached, stop unit and remove from active paths

**Key advantages of this architecture:**
- âœ… Units move naturally with physics (no teleporting)
- âœ… Automatic obstacle avoidance (navmesh pathfinding)
- âœ… Handles complex terrain (slopes, stairs, etc.)
- âœ… Realistic collisions and gravity
- âœ… Smooth, responsive character movement
- âœ… Minimal game server involvement (set-and-forget)

**Your game server only needs to:**
1. Call `RequestMovement()` when unit should move
2. Call `UpdateMovement()` and `PhysicsWorld.Update()` every frame
3. Read final position when movement complete

Everything else is handled automatically! ðŸš€
